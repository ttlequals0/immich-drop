"""
Cookie Manager for yt-dlp authenticated downloads.

Handles parsing raw cookie strings from browser DevTools and converting
them to Netscape cookie file format for yt-dlp consumption.
"""
import os
import sqlite3
import logging
from typing import Optional
from pathlib import Path

logger = logging.getLogger(__name__)

# Domain mappings for supported platforms
PLATFORM_DOMAINS = {
    "instagram": ".instagram.com",
    "tiktok": ".tiktok.com",
    "twitter": ".twitter.com",
    "facebook": ".facebook.com",
    "reddit": ".reddit.com",
    "youtube": ".youtube.com",
}

# Cookie directory (inside /data volume)
COOKIE_DIR = "/data/cookies"


def parse_cookie_string(cookie_str: str) -> list[tuple[str, str]]:
    """
    Parse a raw cookie header string into name-value pairs.

    Args:
        cookie_str: Cookie string like "sessionid=abc123; csrftoken=xyz789"

    Returns:
        List of (name, value) tuples
    """
    cookies = []
    if not cookie_str:
        return cookies

    # Split by semicolon and parse each cookie
    for part in cookie_str.split(";"):
        part = part.strip()
        if not part or "=" not in part:
            continue
        # Split only on first = (value may contain =)
        name, value = part.split("=", 1)
        name = name.strip()
        value = value.strip()
        if name:
            cookies.append((name, value))

    return cookies


def to_netscape_format(platform: str, cookies: list[tuple[str, str]]) -> str:
    """
    Convert cookies to Netscape cookie file format.

    Format per line:
    domain  domain_initial_dot  path  secure  expiry  name  value

    Args:
        platform: Platform name (e.g., "instagram")
        cookies: List of (name, value) tuples

    Returns:
        Netscape format cookie file content
    """
    domain = PLATFORM_DOMAINS.get(platform, f".{platform}.com")

    lines = ["# Netscape HTTP Cookie File"]
    lines.append("# Generated by immich-drop for yt-dlp")
    lines.append("")

    for name, value in cookies:
        # domain, domain_initial_dot, path, secure, expiry, name, value
        # Using TRUE for domain_initial_dot (leading dot), FALSE for secure,
        # and 0 for expiry (session cookie / no expiry)
        line = f"{domain}\tTRUE\t/\tFALSE\t0\t{name}\t{value}"
        lines.append(line)

    return "\n".join(lines) + "\n"


def get_cookie_dir() -> str:
    """Get the cookie directory, creating it if needed."""
    # Use /data/cookies in production, ./data/cookies in dev
    cookie_dir = COOKIE_DIR
    if not os.path.exists("/data"):
        cookie_dir = "./data/cookies"

    os.makedirs(cookie_dir, exist_ok=True)
    return cookie_dir


def write_cookie_file(platform: str, cookie_string: str) -> str:
    """
    Write a Netscape format cookie file for the given platform.

    Args:
        platform: Platform name (e.g., "instagram")
        cookie_string: Raw cookie header string

    Returns:
        Path to the written cookie file
    """
    cookies = parse_cookie_string(cookie_string)
    content = to_netscape_format(platform, cookies)

    cookie_dir = get_cookie_dir()
    filepath = os.path.join(cookie_dir, f"{platform}.txt")

    with open(filepath, "w") as f:
        f.write(content)

    # Set restrictive permissions (owner read/write only)
    try:
        os.chmod(filepath, 0o600)
    except OSError:
        pass  # May fail on some systems

    return filepath


def delete_cookie_file(platform: str) -> bool:
    """
    Delete the cookie file for a platform.

    Args:
        platform: Platform name

    Returns:
        True if deleted, False if not found
    """
    cookie_dir = get_cookie_dir()
    filepath = os.path.join(cookie_dir, f"{platform}.txt")

    if os.path.exists(filepath):
        os.remove(filepath)
        return True
    return False


def get_cookie_file_for_platform(platform: str, state_db: str) -> Optional[str]:
    """
    Look up cookies for a platform from the database and return the cookie file path.

    This is the main function called during downloads. It:
    1. Queries the database for the platform's cookie string
    2. Writes a Netscape format cookie file
    3. Returns the file path (or None if no cookies configured)

    Args:
        platform: Platform name (e.g., "instagram")
        state_db: Path to the SQLite database

    Returns:
        Path to cookie file, or None if no cookies for this platform
    """
    if not platform:
        return None

    platform = platform.lower()

    try:
        conn = sqlite3.connect(state_db)
        cur = conn.cursor()
        cur.execute(
            "SELECT cookie_string FROM platform_cookies WHERE platform = ?",
            (platform,)
        )
        row = cur.fetchone()
        conn.close()

        if not row or not row[0]:
            return None

        cookie_string = row[0]
        filepath = write_cookie_file(platform, cookie_string)
        logger.debug("Using cookies for platform %s from %s", platform, filepath)
        return filepath

    except Exception as e:
        logger.warning("Failed to get cookies for platform %s: %s", platform, e)
        return None


# Database operations for cookie CRUD

def db_list_cookies(state_db: str) -> list[dict]:
    """List all platform cookies."""
    try:
        conn = sqlite3.connect(state_db)
        conn.row_factory = sqlite3.Row
        cur = conn.cursor()
        cur.execute(
            "SELECT platform, cookie_string, created_at, updated_at "
            "FROM platform_cookies ORDER BY platform"
        )
        rows = cur.fetchall()
        conn.close()
        return [dict(row) for row in rows]
    except Exception as e:
        logger.warning("Failed to list cookies: %s", e)
        return []


def db_get_cookie(state_db: str, platform: str) -> Optional[dict]:
    """Get a single platform cookie."""
    try:
        conn = sqlite3.connect(state_db)
        conn.row_factory = sqlite3.Row
        cur = conn.cursor()
        cur.execute(
            "SELECT platform, cookie_string, created_at, updated_at "
            "FROM platform_cookies WHERE platform = ?",
            (platform.lower(),)
        )
        row = cur.fetchone()
        conn.close()
        return dict(row) if row else None
    except Exception as e:
        logger.warning("Failed to get cookie for %s: %s", platform, e)
        return None


def db_upsert_cookie(state_db: str, platform: str, cookie_string: str) -> bool:
    """Create or update a platform cookie."""
    platform = platform.lower()
    try:
        conn = sqlite3.connect(state_db)
        cur = conn.cursor()
        cur.execute(
            """
            INSERT INTO platform_cookies (platform, cookie_string, updated_at)
            VALUES (?, ?, CURRENT_TIMESTAMP)
            ON CONFLICT(platform) DO UPDATE SET
                cookie_string = excluded.cookie_string,
                updated_at = CURRENT_TIMESTAMP
            """,
            (platform, cookie_string)
        )
        conn.commit()
        conn.close()

        # Also write the cookie file immediately
        write_cookie_file(platform, cookie_string)
        logger.info("Saved cookies for platform: %s", platform)
        return True
    except Exception as e:
        logger.exception("Failed to save cookie for %s: %s", platform, e)
        return False


def db_delete_cookie(state_db: str, platform: str) -> bool:
    """Delete a platform cookie."""
    platform = platform.lower()
    try:
        conn = sqlite3.connect(state_db)
        cur = conn.cursor()
        cur.execute(
            "DELETE FROM platform_cookies WHERE platform = ?",
            (platform,)
        )
        deleted = cur.rowcount > 0
        conn.commit()
        conn.close()

        # Also delete the cookie file
        delete_cookie_file(platform)

        if deleted:
            logger.info("Deleted cookies for platform: %s", platform)
        return deleted
    except Exception as e:
        logger.exception("Failed to delete cookie for %s: %s", platform, e)
        return False
